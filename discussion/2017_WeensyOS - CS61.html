<!DOCTYPE html>
<html class="client-js" dir="ltr" lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><script src="2017_WeensyOS%20-%20CS61_files/analytics.js" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app12.us.archive.org';v.server_ms=553;archive_analytics.send_pageview({});});</script><script type="text/javascript" src="2017_WeensyOS%20-%20CS61_files/playback.js" charset="utf-8"></script>
<script type="text/javascript" src="2017_WeensyOS%20-%20CS61_files/wombat.js" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("http://web.archive.org/web");
  __wm.wombat("https://cs61.seas.harvard.edu/wiki/2017/WeensyOS","20200922124003","http://web.archive.org/","web","/_static/",
	      "1600778403");
</script>
<link rel="stylesheet" type="text/css" href="2017_WeensyOS%20-%20CS61_files/banner-styles.css">
<link rel="stylesheet" type="text/css" href="2017_WeensyOS%20-%20CS61_files/iconochive.css">
<!-- End Wayback Rewrite JS Include -->

<meta charset="UTF-8">
<title>2017/WeensyOS - CS61</title>
<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)client-nojs(\s|$)/, "$1client-js$2" );</script>
<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"2017/WeensyOS","wgTitle":"2017/WeensyOS","wgCurRevisionId":7419,"wgRevisionId":7419,"wgArticleId":940,"wgIsArticle":true,"wgIsRedirect":false,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgMonthNamesShort":["","Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],"wgRelevantPageName":"2017/WeensyOS","wgRelevantArticleId":940,"wgRequestId":"24f7d659704cd33773cc24eb","wgIsProbablyEditable":false,"wgRelevantPageIsProbablyEditable":false,"wgRestrictionEdit":[],"wgRestrictionMove":[]});mw.loader.state({"site.styles":"ready","noscript":"ready","user.styles":"ready","user":"ready","site":"ready","user.options":"ready","user.tokens":"loading","mediawiki.legacy.shared":"ready","mediawiki.legacy.commonPrint":"ready","mediawiki.sectionAnchor":"ready","mediawiki.skinning.interface":"ready","skins.vector.styles":"ready"});mw.loader.implement("user.tokens@00axhui",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"editToken":"+\\","patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});mw.loader.load(["mediawiki.page.startup","mediawiki.user","mediawiki.hidpi","mediawiki.page.ready","mediawiki.toc","mediawiki.searchSuggest","skins.vector.js"]);});</script>
<link rel="stylesheet" href="2017_WeensyOS%20-%20CS61_files/load_002.css">
<script async="" src="2017_WeensyOS%20-%20CS61_files/load.php"></script>
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="2017_WeensyOS%20-%20CS61_files/load.css">
<meta name="generator" content="MediaWiki 1.31.0">
<link rel="shortcut icon" href="http://web.archive.org/web/20200922124003im_/https://cs61.seas.harvard.edu/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/opensearch_desc.php" title="CS61 (en)">
<link rel="EditURI" type="application/rsd+xml" href="https://cs61.seas.harvard.edu/wiki/api.php?action=rsd">
<link rel="alternate" type="application/atom+xml" title="CS61 Atom feed" href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/index.php?title=Special:RecentChanges&amp;feed=atom">
<!--[if lt IE 9]><script src="/wiki/load.php?debug=false&amp;lang=en&amp;modules=html5shiv&amp;only=scripts&amp;skin=vector&amp;sync=1"></script><![endif]-->
<script src="2017_WeensyOS%20-%20CS61_files/load_002.php"></script></head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject page-2017_WeensyOS rootpage-2017_WeensyOS skin-vector action-view"><!-- BEGIN WAYBACK TOOLBAR INSERT -->
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  /*min-width:800px !important;*/
}
</style>
<script>__wm.rw(0);</script>
<div id="wm-ipp-base" style="display: block; direction: ltr;" lang="en">
</div><div id="wm-ipp-print">The Wayback Machine - http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/2017/WeensyOS</div>
<div id="donato" style="position:relative;width:100%;">
  <div id="donato-base">
    <iframe id="donato-if" src="2017_WeensyOS%20-%20CS61_files/donate.html" scrolling="no" style="width:100%; height:100%" frameborder="0">
    </iframe>
  </div>
</div><script type="text/javascript">
__wm.bt(650,27,25,2,"web","https://cs61.seas.harvard.edu/wiki/2017/WeensyOS","20200922124003",1996,"/_static/",["/_static/css/banner-styles.css?v=omkqRugM","/_static/css/iconochive.css?v=qtvMKcIJ"], false);
  __wm.rw(1);
</script>
<!-- END WAYBACK TOOLBAR INSERT -->		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<div id="content" class="mw-body" role="main">
			<a id="top"></a>
			<div class="mw-indicators mw-body-content">
</div>
<h1 id="firstHeading" class="firstHeading" lang="en">2017/WeensyOS</h1>			<div id="bodyContent" class="mw-body-content">
				<div id="siteSub" class="noprint">From CS61</div>				<div id="contentSub"></div>
								<div id="jump-to-nav" class="mw-jump">
					Jump to:					<a href="#mw-head">navigation</a>, 					<a href="#p-search">search</a>
				</div>
				<div id="mw-content-text" dir="ltr" class="mw-content-ltr" lang="en"><div class="mw-parser-output"><center>
<p><span style="color:#ad1b71; font-size:larger"><b>Computer Science 61 and E61</b></span><br>
<span>Systems Programming and Machine Organization</span><br>
<span>Fall 2017</span><br>
</p>
</center>
<div id="toc" class="toc"><div class="toctitle" dir="ltr" lang="en"><h2>Contents</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Problem_Set_4:_WeensyOS"><span class="tocnumber">1</span> <span class="toctext">Problem Set 4: WeensyOS</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Get_the_code"><span class="tocnumber">1.1</span> <span class="toctext">Get the code</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Initial_state"><span class="tocnumber">1.2</span> <span class="toctext">Initial state</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Goal"><span class="tocnumber">1.3</span> <span class="toctext">Goal</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="#Notes"><span class="tocnumber">1.4</span> <span class="toctext">Notes</span></a>
<ul>
<li class="toclevel-3 tocsection-6"><a href="#Running_WeensyOS"><span class="tocnumber">1.4.1</span> <span class="toctext">Running WeensyOS</span></a></li>
<li class="toclevel-3 tocsection-7"><a href="#Memory_system_layout"><span class="tocnumber">1.4.2</span> <span class="toctext">Memory system layout</span></a></li>
<li class="toclevel-3 tocsection-8"><a href="#Address_composition"><span class="tocnumber">1.4.3</span> <span class="toctext">Address composition</span></a></li>
<li class="toclevel-3 tocsection-9"><a href="#Kernel_and_process_address_spaces"><span class="tocnumber">1.4.4</span> <span class="toctext">Kernel and process address spaces</span></a></li>
</ul>
</li>
<li class="toclevel-2 tocsection-10"><a href="#Step_1:_Kernel_isolation"><span class="tocnumber">1.5</span> <span class="toctext">Step 1: Kernel isolation</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Step_2:_Isolated_address_spaces"><span class="tocnumber">1.6</span> <span class="toctext">Step 2: Isolated address spaces</span></a></li>
<li class="toclevel-2 tocsection-12"><a href="#Step_3:_Virtual_page_allocation"><span class="tocnumber">1.7</span> <span class="toctext">Step 3: Virtual page allocation</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#Step_4:_Overlapping_address_spaces"><span class="tocnumber">1.8</span> <span class="toctext">Step 4: Overlapping address spaces</span></a></li>
<li class="toclevel-2 tocsection-14"><a href="#Step_5:_Fork"><span class="tocnumber">1.9</span> <span class="toctext">Step 5: Fork</span></a></li>
<li class="toclevel-2 tocsection-15"><a href="#Step_6:_Shared_read-only_memory"><span class="tocnumber">1.10</span> <span class="toctext">Step 6: Shared read-only memory</span></a></li>
<li class="toclevel-2 tocsection-16"><a href="#Step_7:_Freeing_memory"><span class="tocnumber">1.11</span> <span class="toctext">Step 7: Freeing memory</span></a></li>
<li class="toclevel-2 tocsection-17"><a href="#Extra_credit"><span class="tocnumber">1.12</span> <span class="toctext">Extra credit</span></a></li>
<li class="toclevel-2 tocsection-18"><a href="#Turnin"><span class="tocnumber">1.13</span> <span class="toctext">Turnin</span></a></li>
</ul>
</li>
</ul>
</div>

<h1><span class="mw-headline" id="Problem_Set_4:_WeensyOS">Problem Set 4: WeensyOS</span></h1>
<p>In this assignment, you implement process memory isolation, virtual 
memory, and some system calls in a tiny operating system. This will 
introduce you to virtual memory and operating system design.
</p>
<ul><li>Due <b>Fri 11/3</b> 11:59:59pm (extension 1 day later)</li>
<li><b>This assignment may be completed in pairs.</b></li>
<li>You <b>must</b> run this assignment on a Linux machine, such as a 
virtual machine. Running on Mac or a Windows box without a VM will not 
likely work.</li></ul>
<p>You may want to ponder Chapter 9 of the text. The 64-bit x86 virtual memory architecture is described in Section 9.7. The <code>PTE_P</code>, <code>PTE_W</code>, and <code>PTE_U</code> bits are shown in Figure 9.23 and discussed in Section 9.7.1.
</p>
<h2><span class="mw-headline" id="Get_the_code">Get the code</span></h2>
<p>Start with the <code>cs61-psets</code> repository you used for <a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/2017/StdioCache" title="2017/StdioCache">Assignment 3</a>.
</p><p>First, ensure that your repository has a <code>handout</code> remote. Type
</p>
<pre>git remote show handout
</pre>
<p>If this reports an error, run
</p>
<pre>git remote add handout <a rel="nofollow" class="external free" href="http://web.archive.org/web/20200922124003/git://github.com/cs61/cs61-psets-f17.git">git://github.com/cs61/cs61-psets-f17.git</a>
</pre>
<p>Then run <code>git pull handout master</code>. This will <a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/2017/Git#Merges" title="2017/Git">merge</a> our Assignment 4 code with your previous work. If you have any “conflicts” from Assignment 3, <a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/2017/Git#Conflicts" title="2017/Git">resolve them</a> before continuing further. Run <code>git push</code> to save your work back to your personal repository.
</p><p>You may also create a new <code>cs61-psets</code> repository for this assignment.
</p><p>Don’t forget to enter your repository URL on the grading server.
</p><p>Additionally, due to the complexity of this pset, and the 
possibility of breaking the functionality of the kernel if you code in 
some errors, make sure to commit and push your code often! It's very 
important that your commits have working versions of the code, so if 
something goes wrong, you can always go back to a previous commit and 
get back a working copy! At the very least, for this pset, you should be
 committing once per step, so you can go back to the last step if 
necessary.
</p>
<h2><span class="mw-headline" id="Initial_state">Initial state</span></h2>
<p>For this assignment, there is no handy <code>make check</code> 
functionality. Instead, you should run your instance of Weensy OS and 
visually compare it to the images you see below in the assignment.
</p><p>Run <code>make run</code> in your <code>pset4</code> directory. You should see something like this, which shows four versions of the <code>p-allocator</code> process running in parallel:
</p><p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-initial.gif" class="image"><img alt="Fig-memos-initial.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-initial.gif" width="720" height="400"></a>
</p><p>This image loops forever; in an actual run, the bars will move to
 the right and stay there. Don't worry if your image has different 
numbers of K's or otherwise has different details.
</p><p>If your bars run painfully slowly, edit the <code>p-allocator.c</code> file and reduce the <code>ALLOC_SLOWDOWN</code> constant.
</p><p><b>Stop now to read and understand <code>p-allocator.c</code>.</b> Here’s what’s going on in the physical memory display.
</p>
<ul><li>WeensyOS displays the current state of physical and virtual  
memory. Each character represents 4 KB of memory: a single page. There 
are 2 MB of physical memory in total. (How many pages is this?)</li>
<li>WeensyOS runs four processes, 1 through 4. Each process is compiled from the same source code (<code>p-allocator.c</code>), but linked to use a different region of memory.</li>
<li>Each process asks the kernel for more heap space, one page at a 
time, until it runs out of room. As usual, each process's heap begins 
just above its code and global data, and ends just below its stack. The 
processes allocate space at different rates: compared to Process 1, 
Process 2 allocates space twice as quickly, Process 3 goes three times 
faster, and Process 4 goes four times faster. (A random number generator
 is used, so the exact rates may vary.) The marching rows of numbers 
show how quickly the heap spaces for processes 1, 2, 3, and 4 are 
allocated.</li></ul>
<p>Here are two labeled memory diagrams, showing what the characters mean and how memory is arranged.
</p><p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-physmap.gif" class="image"><img alt="Fig-memos-physmap.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-physmap.gif" width="693" height="211"></a>
</p><p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-physmap2.gif" class="image"><img alt="Fig-memos-physmap2.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-physmap2.gif" width="693" height="222"></a>
</p><p>The virtual memory display is similar.
</p>
<ul><li>The virtual memory display cycles between the four processes' 
address spaces. However, all the address spaces are the same for now.</li>
<li>Blank spaces in the virtual memory display correspond to unmapped 
addresses. If a process (or the kernel) tries to access such an address,
 the processor will page fault.</li>
<li>The character shown at address X in the virtual memory display identifies the owner of the corresponding <i>physical</i> page.</li>
<li>In the virtual memory display, a character is <b style="color:#000000;background-color:#ff0000">reverse video</b> if an application process is allowed to access the corresponding address. Initially, <em>any</em> process can modify <em>all</em> of physical memory, including the kernel. Memory is not properly isolated.</li></ul>
<h2><span class="mw-headline" id="Goal">Goal</span></h2>
<p>You will implement complete and correct memory isolation for WeensyOS
 processes. Then you'll implement full virtual memory, which will 
improve utilization. You'll implement fork—creating new processes at 
runtime—and exit—destroying processes at runtime.
</p><p>We need to provide a lot of support code for this assignment, but
 the code you write will be limited. Our solutions contain less than 200
 lines. All your code goes in <code>kernel.c</code> (except for part of step 6).
</p>
<h2><span class="mw-headline" id="Notes">Notes</span></h2>
<h3><span class="mw-headline" id="Running_WeensyOS">Running WeensyOS</span></h3>
<p>Read the <code>README-OS.md</code> file for information on how to run WeensyOS. If QEMU’s default display causes accessibility problems, you will want to run <code>make run-console</code>. To make <code>run-console</code> the default, run <code>export QEMUCONSOLE=1</code> in your shell.
</p><p>There are several ways to debug WeensyOS. We recommend adding <code>log_printf</code> statements to your code (the output of <code>log_printf</code> is written to the file <code>log.txt</code>), and use assertions to catch problems early (for instance, call <code>check_page_table_mappings</code> and <code>check_page_table_ownership</code> to test a page table for obvious issues).
</p>
<h3><span class="mw-headline" id="Memory_system_layout">Memory system layout</span></h3>
<p>WeensyOS memory system layout is described by several constants.
</p>
<table class="simple">
<tbody><tr>
<td style="padding-right: 0.5em"><code>KERNEL_START_ADDR</code>
</td>
<td>Start of kernel code.
</td></tr>
<tr>
<td><code>KERNEL_STACK_TOP</code>
</td>
<td>Top of kernel stack. The kernel stack is one page long.
</td></tr>
<tr>
<td><code>console</code>
</td>
<td>CGA console memory.
</td></tr>
<tr>
<td><code>PROC_START_ADDR</code>
</td>
<td>Start of application code. Applications should not be able to access memory below <code>PROC_START_ADDR</code>, except for the single page at <code>console</code>.
</td></tr>
<tr>
<td><code>MEMSIZE_PHYSICAL</code>
</td>
<td>Size of physical memory in bytes. WeensyOS does not support physical addresses ≥ <code>MEMSIZE_PHYSICAL</code>. Equals 0x200000 (2MB).
</td></tr>
<tr>
<td><code>MEMSIZE_VIRTUAL</code>
</td>
<td>Size of virtual memory. WeensyOS does not support virtual addresses ≥ <code>MEMSIZE_VIRTUAL</code>. Equals 0x300000 (3MB).
</td></tr></tbody></table>
<h3><span class="mw-headline" id="Address_composition">Address composition</span></h3>
<p>WeensyOS uses several macros to handle addresses. They are defined at the top of <code>x86-64.h</code>. The most important include:
</p>
<table class="simple">
<tbody><tr>
<td><code>PAGESIZE</code>
</td>
<td>Size of a memory page. Equals 4096 (or, equivalently, <code>1 &lt;&lt; 12</code>).
</td></tr>
<tr>
<td style="padding-right: 0.5em"><code>PAGENUMBER(addr)</code>
</td>
<td>The page number for the page containing <code>addr</code>. Expands to something like <code>addr / PAGESIZE</code>.
</td></tr>
<tr>
<td><code>PAGEADDRESS(pn)</code>
</td>
<td>The initial address in page number <code>pn</code>. Expands to something like <code>pn * PAGESIZE</code>.
</td></tr>
<tr>
<td><code>PAGEINDEX(addr,&nbsp;level)</code>
</td>
<td>The <code>level</code>th page table index for <code>addr</code>. <code>level</code>
 must be between 0 and 3; 0 returns the level-1 page table index 
(address bits 39–47), 1 returns the level-2 index (bits 30–38), 2 
returns the level-3 index (bits 21–29), and 3 returns the level-4 index 
(bits 12–20).
</td></tr>
<tr>
<td><code>PTE_ADDR(pe)</code>
</td>
<td>The physical address contained in a page table entry <code>pe</code>. Obtained by masking off the flag bits (setting the low-order 12 bits to zero).
</td></tr></tbody></table>
<p><b>You should both understand what these macros represent and be able to derive values if you were given a different pagesize.</b>
</p>
<h3><span class="mw-headline" id="Kernel_and_process_address_spaces">Kernel and process address spaces</span></h3>
<p>WeensyOS begins with the kernel and all processes sharing a single address space. This is defined by the <code>kernel_pagetable</code> page table. <code>kernel_pagetable</code> is initialized to the <i>identity mapping</i>: virtual address X maps to physical address X.
</p><p>As you work through the pset, you will shift processes to using 
their own independent address spaces, where each process can access only
 a subset of physical memory.
</p><p>The kernel, though, still needs the ability to access <i>any</i> location in physical memory. Therefore, all kernel functions run using the <code>kernel_pagetable</code> page table. Thus, in kernel functions, each virtual address maps to the physical address with the same number. The <code>exception</code> function explicitly installs <code>kernel_pagetable</code> when it begins.
</p><p>WeensyOS system calls are more expensive than they need to be, since every system call switches address spaces twice (once to <code>kernel_pagetable</code>
 and once back to the process’s page table). Real operating systems 
avoid this overhead. In real operating systems, kernels access memory 
using <i>process</i> page tables, rather than a kernel-specific <code>kernel_pagetable</code>. This makes the kernel code more complicated, since kernels can’t always access all of physical memory directly.
</p>
<h2><span class="mw-headline" id="Step_1:_Kernel_isolation">Step 1: Kernel isolation</span></h2>
<p>WeensyOS processes could stomp all over the kernel’s memory if they wanted. Better stop that. Change <code>kernel</code>,
 the kernel initialization function, so that kernel memory is 
inaccessible to applications—except for the memory holding the CGA 
console (the single page at <code>(uintptr_t) console == 0xB8000</code>).
</p><p>When you are done, WeensyOS should look like this. In the virtual
 map, kernel memory is no longer reverse-video, since the user can’t 
access it. Note the lonely CGA console memory block.
</p><p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-kernelprot.gif" class="image"><img alt="Fig-memos-kernelprot.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-kernelprot.gif" width="726" height="426"></a>
</p><p>Hints:
</p>
<ul><li>Use <code>virtual_memory_map</code>. A description of this function is in <code>kernel.h</code>. You will benefit from reading all the function descriptions in <code>kernel.h</code>. You can supply <code>NULL</code> for the <code>allocator</code> argument for now.</li>
<li>If you really want to look at the code for <code>virtual_memory_map</code>, it is in <code>k-hardware.c</code>, along with many other hardware functions.</li>
<li>The <code>perm</code> argument to <code>virtual_memory_map</code> is a bitwise-or of zero or more <code>PTE</code> flags, <code>PTE_P</code>, <code>PTE_W</code>, and <code>PTE_U</code>. <code>PTE_P</code> marks <b>P</b>resent pages (pages that are mapped). <code>PTE_W</code> marks <b>W</b>ritable pages. <code>PTE_U</code> marks <b>U</b>ser-accessible pages—pages accessible to applications. You want kernel memory to be mapped with permissions <code>PTE_P|PTE_W</code>, which will prevent applications from reading or writing the memory, while allowing the kernel to both read and write.</li>
<li>Make sure that your <code>sys_page_alloc</code> system call preserves kernel isolation: Applications shouldn’t be able to use <code>sys_page_alloc</code> to screw up the kernel.</li></ul>
<p>When you're done with this step, make sure to commit and push your code!
</p>
<h2><span class="mw-headline" id="Step_2:_Isolated_address_spaces">Step 2: Isolated address spaces</span></h2>
<p>Implement process isolation by giving each process its own independent page table. Your OS should look like this:
</p><p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-perprocess.gif" class="image"><img alt="Fig-memos-perprocess.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-perprocess.gif" width="722" height="429"></a>
</p><p>Thus, each process only has permission to access its own pages. 
You can tell this because only its own pages are shown in reverse video.
</p><p>What goes in per-process page tables:
</p>
<ul><li>The initial mappings for addresses less than <code>PROC_START_ADDR</code> should be copied from those in <code>kernel_pagetable</code>. You can use a loop with <code>virtual_memory_lookup</code> and <code>virtual_memory_map</code>
 to copy them. Alternately, you can copy the mappings from the kernel’s 
page table into the new page tables; this is faster, but make sure you 
copy the right data!</li>
<li>The initial mappings for the user area—addresses greater than or equal to <code>PROC_START</code>—should be inaccessible to user processes (no <code>PTE_U</code>). In our solution (shown above), these addresses are <i>totally</i>
 inaccessible (so they show as blank), but you can also change this so 
that the mappings are still there, but accessible only to the kernel, as
 in this diagram:</li></ul>
<p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-isolated2.gif" class="image"><img alt="Fig-memos-isolated2.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-isolated2.gif" width="722" height="429"></a>
</p><p>The reverse video shows that this OS also implements process isolation correctly.
</p><p>How to implement per-process page tables:
</p>
<ul><li>Change <code>process_setup</code> to create per-process page tables.</li>
<li>We suggest you write a <code>copy_pagetable(x86_64_pagetable* pagetable, int8_t owner)</code> function that allocates and returns a new page table, initialized as a <b>full copy</b> of <code>pagetable</code> (including <b>all</b> mappings from <code>pagetable</code>). This function will be useful in Step 5. In <code>process_setup</code> you can modify the page table returned by <code>copy_pagetable</code> according to the requirements above. Your function can use <code>pageinfo</code> to find free pages to use for page tables. Read about <code>pageinfo</code> at the top of <code>kernel.c</code>.</li>
<li>Remember that the x86-64 architecture uses <i>four-level</i> page tables.</li>
<li>The easiest way to copy page tables involves an <i>allocator</i> function suitable for passing to <code>virtual_memory_map</code>.</li>
<li>You’ll need at least to allocate a level-1 page table and initialize
 it to zero. You can also set up the whole four-level page table 
skeleton (for addresses <code>0…MEMSIZE_VIRTUAL - 1</code>) yourself; then you don’t need an allocator function.</li>
<li>A physical page is free if <code>pageinfo[PAGENUMBER].refcount == 0</code>. Look at the other code in <code>kernel.c</code> for some hints on how to examine the <code>pageinfo</code> array.</li>
<li>All of process <code>P</code>’s page table pages must have <code>pageinfo[...].owner == P</code>
 or our checking functions will fail. This will affect your allocator 
function. (Hint: Don’t forget that global variables are allowed in this 
class!)</li></ul>
<p>If you create an incorrect page table, WeensyOS might crazily reboot. Don’t panic! Add <code>log_printf</code> statements. Another useful technique: <b>add infinite loops to your kernel</b> to track down exactly where a fault occurs. (If the OS stops, then the crash occurs after the infinite loop.)
</p><p>Again, once finished with step 2, commit and push!
</p>
<h2><span class="mw-headline" id="Step_3:_Virtual_page_allocation">Step 3: Virtual page allocation</span></h2>
<p>So far, WeensyOS processes use <i>physical page allocation</i>: the page with <i>physical</i> address X is used to satisfy the <code>sys_page_alloc(X)</code> allocation request for <i>virtual</i> address X. This is inflexible and limits utilization. Change the implementation of the <code>INT_SYS_PAGE_ALLOC</code> system call so that it can use <i>any free physical page</i> to satisfy a <code>sys_page_alloc(X)</code> request.
</p><p>Your new <code>INT_SYS_PAGE_ALLOC</code> code must perform the following tasks.
</p>
<ul><li>Find a free physical page using the <code>pageinfo</code> array. Return <code>-1</code>
 to the application if you can’t find one. Use any algorithm you like to
 find a free physical page; we just return the first one we find.</li>
<li>Record the physical page’s allocation in <code>pageinfo</code>.</li>
<li>Map that physical page at the requested virtual address.</li></ul>
<p>Don’t modify the <code>physical_page_alloc</code> helper function, which is also used by the program loader. You can write a new function if you want.
</p><p>Here’s how our OS looks after this step.
</p><p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-isolated.gif" class="image"><img alt="Fig-memos-isolated.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-isolated.gif" width="726" height="426"></a>
</p><p>Now commit and push your code before moving on to step 4!
</p>
<h2><span class="mw-headline" id="Step_4:_Overlapping_address_spaces">Step 4: Overlapping address spaces</span></h2>
<p>Now the processes are isolated, which is awesome. But they’re still 
not taking full advantage of virtual memory. Isolated address spaces can
 use <em>the same</em> virtual addresses for <em>different</em> physical memory. There’s no need to keep the four process address spaces disjoint.
</p><p>In this step, change each process’s stack to start from address <code>0x300000 == MEMSIZE_VIRTUAL</code>.  Now the processes have enough heap room to use up all of physical memory!
</p><p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-overlapping.gif" class="image"><img alt="Fig-memos-overlapping.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-overlapping.gif" width="726" height="426"></a>
</p><p>If there’s no physical memory available, <code>sys_page_alloc</code> should return an error to the caller (by returning -1). (Our solution additionally prints “<code>Out of physical memory!</code>” to the console when this happens; you don’t need to.)
</p><p>As always, make sure to commit and push after finishing this step!
</p>
<h2><span class="mw-headline" id="Step_5:_Fork">Step 5: Fork</span></h2>
<p>The <code>fork</code> system call is one of Unix’s great ideas. It starts a new process as a <i>copy</i> of an existing process. The <code>fork</code>
 system call appears to return twice, once to each process. To the child
 process, it returns 0. To the parent process, it returns the child’s 
process ID.
</p><p>Run WeensyOS with <code>make run</code> or <code>make run-console</code>. At any time, press the ‘<code>f</code>’ key. This will soft-reboot WeensyOS and ask it to run a single <code>p-fork</code> process, rather than the gang of <code>allocator</code>s. You should see something like this:
</p><p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-forkinitial.gif" class="image"><img alt="Fig-memos-forkinitial.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-forkinitial.gif" width="726" height="426"></a>
</p><p>This is because you haven’t implemented <code>fork</code> yet.
</p><p>Implement <code>fork</code>.
</p>
<ul><li>When a process calls <code>fork</code>, look for a free process slot in the <code>processes[]</code> array. Don’t use slot 0. If no slot exists, return <code>-1</code> to the caller.</li>
<li>If a free slot is found, make a copy of <code>current-&gt;p_pagetable</code>, the forking process’s page table, using your function from earlier.</li>
<li>But you must also copy the <i>process data</i> in every application 
page shared by the two processes. The processes should not share any 
writable memory except the console (otherwise they wouldn’t be 
isolated). So <code>fork</code> must examine every virtual address in 
the old page table. Whenever the parent process has an 
application-writable page at virtual address <code>V</code>, then <code>fork</code> must allocate a new physical page <code>P</code>; copy the data from the parent’s page into <code>P</code>, using <code>memcpy</code>; and finally map page <code>P</code> at address <code>V</code> in the child process’s page table.</li>
<li>The child process’s registers are initialized as a copy of the parent process’s registers, except for <code>reg_rax</code>.</li>
<li>Use <code>virtual_memory_lookup</code> to query the mapping between virtual and physical addresses in a page table.</li></ul>
<p>When you’re done, you should see something like this after pressing ‘<code>f</code>’.
</p><p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-fork.gif" class="image"><img alt="Fig-memos-fork.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-fork.gif" width="726" height="426"></a>
</p><p>An image like this means you forgot to copy the data for some pages, so the processes are actually <i>sharing</i> stack and/or data pages:
</p><p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-badfork.gif" class="image"><img alt="Fig-memos-badfork.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-badfork.gif" width="726" height="426"></a>
</p><p>Don't forget to commit and push after finishing fork!
</p>
<h2><span class="mw-headline" id="Step_6:_Shared_read-only_memory">Step 6: Shared read-only memory</span></h2>
<p>It’s wasteful for <code>fork()</code> to copy <i>all</i> of a process’s memory. For example, most processes, including <code>p-fork</code>,
 never change their code. So what if we shared the memory containing the
 code? That’d be fine for process isolation, as long as neither process 
could write the code.
</p><p>Change the process loader in <code>k-loader.c</code> to detect <i>read-only</i> program segments and map them as read-only for applications (<code>PTE_P|PTE_U</code>). A program segment <code>ph</code> is read-only iff <code>(ph-&gt;p_flags &amp; ELF_PFLAG_WRITE) == 0</code>.
</p><p>Your <code>fork()</code> code shouldn’t copy shareable pages, but it <i>should</i> keep track of the number of active references to each user page. Specifically, if <code>pageinfo[pn].refcount &gt; 0</code> and <code>pageinfo[pn].owner &gt; 0</code>, then <code>pageinfo[pn].refcount</code> should equal the number of times <code>pn</code> is mapped in process page tables.
</p><p>When you’re done, running <code>p-fork</code> should look like this:
</p><p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-sharedreadonly.gif" class="image"><img alt="Fig-memos-sharedreadonly.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-sharedreadonly.gif" width="726" height="426"></a>
</p><p>Each process’s virtual address space begins with a darker-colored
 “1”. The dark color indicates that the corresponding physical page has 
reference count (<code>refcount</code>) greater than 1. (The color 
difference is only visible on graphical QEMU; the console version 
doesn’t distinguish between light reverse-video and dark reverse-video.)
</p><p>Hint:
</p>
<ul><li>Mark a program segment read-only <i>after</i> the <code>memcpy</code> and <code>memset</code> operations that add data to the segment. Otherwise you’ll get a fault.</li></ul>
<p>Again, commit and push!
</p>
<h2><span class="mw-headline" id="Step_7:_Freeing_memory">Step 7: Freeing memory</span></h2>
<p>So far none of your test programs have ever freed memory or exited. 
Memory allocation’s pretty easy until you add free! So let’s do that, by
 allowing applications to exit. In this exercise you’ll implement the <code>sys_exit</code> system call, which exits the current process.
</p><p>This exercise is worth fewer points than others, but it is 
important: freeing memory will tend to expose weaknesses and problems in
 your other code.
</p><p>To test your work, use <code>make run</code> and then type ‘<code>e</code>’. This reboots WeensyOS to run the <code>p-forkexit</code> program. (Initially it’ll crash because <code>sys_exit()</code> isn’t implemented yet.) <code>p-forkexit</code> combines two types of behavior:
</p>
<ul><li>Process 1 forks children indefinitely.</li>
<li>The child processes, #2 and up, are memory allocators, as in the 
previous parts of the pset. But with small probability at each step, 
each child process either exits or attempts to fork a new child.</li></ul>
<p>The result is that once your code is correct, <code>p-forkexit</code> makes crazy patterns forever. An example:
</p><p><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/File:Fig-memos-forkexit.gif" class="image"><img alt="Fig-memos-forkexit.gif" src="2017_WeensyOS%20-%20CS61_files/Fig-memos-forkexit.gif" width="726" height="426"></a>
</p><p>Your picture might look a little different; for example, thanks 
to Step 6, your processes should share a code page, which would appear 
as a darker-colored “1”.
</p><p>Here’s your task.
</p>
<ul><li><code>sys_exit</code> should mark a process as free and free all
 of its memory. This includes the process’s code, data, heap, and stack 
pages, as well as the pages used for its page directory and page table 
pages.</li>
<li>In <code>p-forkexit</code>, unlike in previous parts of the pset, <code>sys_fork</code>
 can run when there isn’t quite enough memory to create a new process. 
Your code should handle this case. If there isn’t enough free memory to 
allocate a process, <code>fork()</code> should clean up after itself 
(i.e., free any memory that was allocated for the new process before 
memory ran out), and then return <code>-1</code> to the caller. There should be no memory leaks.</li></ul>
<p>The <code>virtual_memory_check</code> function, which runs periodically, should help catch some errors. Feel free to add checks of your own.
</p>
<h2><span class="mw-headline" id="Extra_credit">Extra credit</span></h2>
<p>If you are finished and can't wait to do more of this type of work, try:
</p>
<ul><li>Copy-on-write page allocation!</li>
<li>Faster system calls, for instance using the <code>syscall</code> and <code>sysexit</code> instructions!</li></ul>
<h2><span class="mw-headline" id="Turnin">Turnin</span></h2>
<p>You will turn in your code by <b>pushing your git repository to github.com/cs61/YOUR-PSET_REPO.git</b> and updating <a rel="nofollow" class="external text" href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/cs61/2017/">the grading server</a>.
</p>
<!-- 
NewPP limit report
Cached time: 20200921164739
Cache expiry: 86400
Dynamic content: false
CPU time usage: 0.106 seconds
Real time usage: 0.116 seconds
Preprocessor visited node count: 77/1000000
Preprocessor generated node count: 92/1000000
Post‐expand include size: 201/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/40
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    1.398      1 Template:Header2017
100.00%    1.398      1 -total
-->
</div>
<!-- Saved in parser cache with key wikidb:pcache:idhash:940-0!canonical and timestamp 20200921164739 and revision id 7419
 -->
</div>					<div class="printfooter">
						Retrieved from "<a dir="ltr" href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/index.php?title=2017/WeensyOS&amp;oldid=7419">https://cs61.seas.harvard.edu/wiki/index.php?title=2017/WeensyOS&amp;oldid=7419</a>"					</div>
				<div id="catlinks" class="catlinks catlinks-allhidden" data-mw="interface"></div>				<div class="visualClear"></div>
							</div>
		</div>
		<div id="mw-navigation">
			<h2>Navigation menu</h2>
			<div id="mw-head">
									<div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
						<h3 id="p-personal-label">Personal tools</h3>
						<ul>
							<li id="pt-login"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/index.php?title=Special:UserLogin&amp;returnto=2017%2FWeensyOS" title="You are encouraged to log in; however, it is not mandatory [o]" accesskey="o">Log in</a></li>						</ul>
					</div>
									<div id="left-navigation">
										<div id="p-namespaces" role="navigation" class="vectorTabs" aria-labelledby="p-namespaces-label">
						<h3 id="p-namespaces-label">Namespaces</h3>
						<ul>
							<li id="ca-nstab-main" class="selected"><span><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/2017/WeensyOS" title="View the content page [c]" accesskey="c">Page</a></span></li><li id="ca-talk" class="new"><span><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/index.php?title=Talk:2017/WeensyOS&amp;action=edit&amp;redlink=1" rel="discussion" title="Discussion about the content page (page does not exist) [t]" accesskey="t">Discussion</a></span></li>						</ul>
					</div>
										<div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
												<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label">
						<h3 id="p-variants-label">
							<span>Variants</span>
						</h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
									</div>
				<div id="right-navigation">
										<div id="p-views" role="navigation" class="vectorTabs" aria-labelledby="p-views-label">
						<h3 id="p-views-label">Views</h3>
						<ul>
							<li id="ca-view" class="collapsible selected"><span><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/2017/WeensyOS">Read</a></span></li><li id="ca-viewsource" class="collapsible"><span><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/index.php?title=2017/WeensyOS&amp;action=edit" title="This page is protected.
You can view its source [e]" accesskey="e">View source</a></span></li><li id="ca-history" class="collapsible"><span><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/index.php?title=2017/WeensyOS&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></span></li>						</ul>
					</div>
										<div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
						<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label">
						<h3 id="p-cactions-label"><span>More</span></h3>
						<div class="menu">
							<ul>
															</ul>
						</div>
					</div>
										<div id="p-search" role="search">
						<h3>
							<label for="searchInput">Search</label>
						</h3>
						<form action="/web/20200922124003/https://cs61.seas.harvard.edu/wiki/index.php" id="searchform">
							<div id="simpleSearch">
								<input type="search" name="search" placeholder="Search CS61" title="Search CS61 [f]" accesskey="f" id="searchInput"><input type="hidden" value="Special:Search" name="title"><input type="submit" name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"><input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton">							</div>
						</form>
					</div>
									</div>
			</div>
			<div id="mw-panel">
				<div id="p-logo" role="banner"><a class="mw-wiki-logo" href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/2018/Home" title="Visit the main page"></a></div>
						<div class="portal" role="navigation" id="p-navigation" aria-labelledby="p-navigation-label">
			<h3 id="p-navigation-label">Navigation</h3>
			<div class="body">
								<ul>
					<li id="n-mainpage-description"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/2018/Home" title="Visit the main page [z]" accesskey="z">Main page</a></li><li id="n-portal"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/CS61:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li><li id="n-currentevents"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/CS61:Current_events" title="Find background information on current events">Current events</a></li><li id="n-recentchanges"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-randompage"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/Special:Random" title="Load a random page [x]" accesskey="x">Random page</a></li><li id="n-help"><a href="http://web.archive.org/web/20200922124003/https://www.mediawiki.org/wiki/Special:MyLanguage/Help:Contents" title="The place to find out">Help</a></li>				</ul>
							</div>
		</div>
			<div class="portal" role="navigation" id="p-tb" aria-labelledby="p-tb-label">
			<h3 id="p-tb-label">Tools</h3>
			<div class="body">
								<ul>
					<li id="t-whatlinkshere"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/Special:WhatLinksHere/2017/WeensyOS" title="A list of all wiki pages that link here [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/Special:RecentChangesLinked/2017/WeensyOS" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-specialpages"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-print"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/index.php?title=2017/WeensyOS&amp;printable=yes" rel="alternate" title="Printable version of this page [p]" accesskey="p">Printable version</a></li><li id="t-permalink"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/index.php?title=2017/WeensyOS&amp;oldid=7419" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/index.php?title=2017/WeensyOS&amp;action=info" title="More information about this page">Page information</a></li>				</ul>
							</div>
		</div>
				</div>
		</div>
				<div id="footer" role="contentinfo">
						<ul id="footer-info">
								<li id="footer-info-lastmod"> This page was last edited on 3 November 2017, at 17:49.</li>
							</ul>
						<ul id="footer-places">
								<li id="footer-places-privacy"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/CS61:Privacy_policy" title="CS61:Privacy policy">Privacy policy</a></li>
								<li id="footer-places-about"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/CS61:About" title="CS61:About">About CS61</a></li>
								<li id="footer-places-disclaimer"><a href="http://web.archive.org/web/20200922124003/https://cs61.seas.harvard.edu/wiki/CS61:General_disclaimer" title="CS61:General disclaimer">Disclaimers</a></li>
							</ul>
										<ul id="footer-icons" class="noprint">
										<li id="footer-poweredbyico">
						<a href="http://web.archive.org/web/20200922124003/https://www.mediawiki.org/"><img src="2017_WeensyOS%20-%20CS61_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="2017_WeensyOS%20-%20CS61_files/poweredby_mediawiki_132x47.png 1.5x, 2017_WeensyOS%20-%20CS61_files/poweredby_mediawiki_176x62.png 2x" width="88" height="31"></a>					</li>
									</ul>
						<div style="clear: both;"></div>
		</div>
		<script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.106","walltime":"0.116","ppvisitednodes":{"value":77,"limit":1000000},"ppgeneratednodes":{"value":92,"limit":1000000},"postexpandincludesize":{"value":201,"limit":2097152},"templateargumentsize":{"value":0,"limit":2097152},"expansiondepth":{"value":2,"limit":40},"expensivefunctioncount":{"value":0,"limit":100},"unstrip-depth":{"value":0,"limit":20},"unstrip-size":{"value":0,"limit":5000000},"timingprofile":["100.00%    1.398      1 Template:Header2017","100.00%    1.398      1 -total"]},"cachereport":{"timestamp":"20200921164739","ttl":86400,"transientcontent":false}}});});</script><script>(window.RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":178});});</script>
	


<script>mendeleyWebImporter = {
  downloadPdfs(t,e) { return this._call('downloadPdfs', [t,e]); },
  open() { return this._call('open', []); },
  setLoginToken(t) { return this._call('setLoginToken', [t]); },
  _call(methodName, methodArgs) {
    const id = Math.random();
    window.postMessage({ id, token: '0.23355111609554657', methodName, methodArgs }, 'http://web.archive.org');
    return new Promise(resolve => {
      const listener = window.addEventListener('message', event => {
        const data = event.data;
        if (typeof data !== 'object' || !('result' in data) || data.id !== id) return;
        window.removeEventListener('message', listener);
        resolve(data.result);
      });
    });
  }
};</script><script src="2017_WeensyOS%20-%20CS61_files/inject.js"></script></body></html>
<!--
     FILE ARCHIVED ON 12:40:03 Sep 22, 2020 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 09:42:39 Aug 08, 2021.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  PetaboxLoader3.datanode: 340.917 (4)
  CDXLines.iter: 19.103 (3)
  cdx.remote: 0.079
  captures_list: 441.201
  exclusion.robots.policy: 0.268
  esindex: 0.017
  load_resource: 86.578
  LoadShardBlock: 412.616 (3)
  exclusion.robots: 0.278
  PetaboxLoader3.resolve: 89.781 (2)
-->